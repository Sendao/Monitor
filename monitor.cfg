# Configuration HOWTO:
# 
# 1. Create a group. "group: <name>"
# 2. Configure log aggregation: "logto: <some_log_aggregate_file>"
# 3. Monitor some logfile. "logfile: <some_log_file>"
# 3a. Monitor another logfile. Each group can support multiple logfiles and processes.
# 4. Monitor a process. "process: <name>".
# 4A. Add details. "service: <servicename>" will connect to a service.
# 4B. Set the process's autostart parameter. "autostart: on"
# 4C. Set the process's keeprunning parameter. "keeprunning: on"
# ... note 'on' or 'true' both work, off/false as well, 0/1, etc.
# 5. Monitor a file for changes. "watch: <directory> <filename>"
# 5A. Add a trigger. "restart" or a command to run.
# 5. repeat as necessary.
# 4. repeat as necessary. Groups with multiple processes might be restartable at some point in the future
# 3. repeat as necessary.
# 1. repeat as necessary. You can have as many groups as you need aggregating to separate logfiles.
#
# Reference
#
# Main Commands:
#
# group: <groupname> - Create a process logfile group.
# ... <group options>
#
# logfile: <path> - Monitor a particular logfile.
# ... <logfile options>
#
# process: <processname> - Monitor a particular process.
# ... <process options>
#
# watch: <directory> <pattern[|pattern...]> - Monitor a directory/pattern
# for any changes. When the files change, the group will restart.
#
# Group Options:
# logto: <path> - aggregates all other logfiles to some location.
#
# Process Options:
# noshell - runs a process without 'bash'
# newsid - starts the new process (bash or not) in a new session
# autostart - monitor should start and restart the process and keep it online
# shellpid - if the process is in a bash shell, scan its pid on startup via 'cmdline & fg'
# psgrep: <regex> - scan for the pid. this will identify the first process as primary until it exits, which creates a logged crash.
# service: <name> - The name of a service, which overrides start/stop commands and reads service status for its checkup.
# startcmd: <runtime> - what to run to start the process
# stopcmd: <runtime> - to stop the process
#
# Sample
#


# Group1: runs a service. uses ps and grep to locate the service. aggregates logfiles to '/tmp/demo0_all.log'
group: One
logto: /tmp/demo0_all.log
logfile: /tmp/demo0.log
process: Demo: Runner 0
service: demo0
psgrep: demo0
autostart: on

# Group2: runs a shelled process and scans its pid from bash on startup. aggregates logfiles
group: Two
logto: /tmp/demo1_all.log
logfile: /tmp/demo1.log
process: Demo: Runner 1
shellpid: true
newsid: yes
autostart: on
cwd: /home/sendao/as/monitor
start: /home/sendao/as/monitor/demo1

# Group3: runs a process in fork() and exec() with no extra bash shell. scans pid from fork().
group: Three
logto: /tmp/demo2_all.log
logfile: /tmp/demo2.log
process: Demo: Runner 2
noshell: on
autostart: yes
newsid: yes
cwd: /home/sendao/as/monitor
start: /home/sendao/as/monitor/demo2

# Group4: runs a shelled npm process, using psgrep to find its shelled pids as 'node server.js'.
group: Web
logto: /tmp/web_all.log
process: node server
cwd: /home/sendao/as/watch
start: npm start
newsid: yes
psgrep: node server.js
autostart: on


